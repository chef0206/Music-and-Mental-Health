# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MgZOCLoBZL_gw0wY_WFWCygRjiyXQLzY
"""
import pandas as pd
import numpy as np

df = pd.read_csv('mxmh_survey_results.csv')
# df.head()

df.drop(['Timestamp', 'Permissions'], axis=1, inplace=True)

from sklearn.impute import KNNImputer,SimpleImputer
impute = KNNImputer()
simple_impute = SimpleImputer(missing_values='NAN', strategy='mean')
df['Age'] = impute.fit_transform(df['Age'].values.reshape(-1,1))
df['BPM'] = impute.fit_transform(df['BPM'].values.reshape(-1,1))
df['Primary streaming service'] = df['Primary streaming service'].fillna(df['Primary streaming service'].mode()[0])
df['While working'] = df['While working'].fillna(df['While working'].mode()[0])
df['Instrumentalist'] = df['Instrumentalist'].fillna(df['Instrumentalist'].mode()[0])
df['Composer'] = df['Composer'].fillna(df['Composer'].mode()[0])
df['Foreign languages'] = df['Foreign languages'].fillna(df['Foreign languages'].mode()[0])
df['Music effects'] = df['Music effects'].fillna(df['Music effects'].mode()[0])

# df.isnull().sum()


q1 = np.percentile(df['Age'],25)

q3 = np.percentile(df['Age'],75)
iqr = q3 - q1
lb = q1 - (1.5 * iqr)
up = q3 + (1.5 * iqr)

def to_detect_outliers(X,features):
    final_outlier_index = []
    for col in features:
        q1 = np.percentile(X[col],25)
        q3 = np.percentile(X[col],75)
        IQR = (q3 - q1) * 1.5
        lower_limit = q1 - IQR
        upper_limit = q3 + IQR
        outlier_index = X[col][(X[col]<lower_limit)|(X[col]>upper_limit)].index.to_list()
        final_outlier_index.extend(outlier_index)
    out_index = list(set(final_outlier_index))
    out_index.sort()
    # print(out_index)
    # print("----------------------------------------------------------------------")
    # print(f'There are {len(out_index)} records which fall under outliers' )
    # print("----------------------------------------------------------------------")
    # print(f'the percentage of outliers in the dataset is : {round((len(out_index)/len(df)*100),2)}% ')

feature = [feature for feature in df.columns if df[feature].dtypes != 'O' ]
features = ['Age', 'Hours per day', 'BPM']
to_detect_outliers(df,features)

np.where(df['Age']>up,up,np.where(df['Age']<lb,lb,df['Age']))

def capping_outliers(df,feature):
    for col in feature:
        q1 = np.percentile(df[col],25)
        q3 = np.percentile(df[col],75)
        IQR = (q3-q1) * 1.5
        upper_bond = q3 + IQR
        lower_bond = q1 - IQR
        df[col] = np.where(df[col]>upper_bond,upper_bond,np.where(df[col]<lower_bond,lower_bond,df[col]))
        #name_of_col      if is true , replace it with upper bond , else (replace is lower bond if both 
        # condition are failed then keep remaining data as it  )

capping_outliers(df,features)

df.head()

numerical_feature = [feature for feature in df.columns if df[feature].dtypes != 'O' ]
numerical_features = numerical_feature[:-1]
# numerical_features

categorical_feature = [feature for feature in df.columns if df[feature].dtypes == 'O' ]
index = [df.columns.get_loc(c) for c in numerical_feature]
# numerical_features

df['Music effects'].value_counts()

df['Music effects'] = df['Music effects'].map({'Improve':0,'No effect':1,'Worsen':2})

df.head()

from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import LabelEncoder,OneHotEncoder
from sklearn.tree import DecisionTreeClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
import category_encoders as ce
from sklearn.ensemble import GradientBoostingClassifier

numerical_process = Pipeline(
    steps = [('scaler',StandardScaler())]
)

from sklearn import set_config
set_config(display="diagram")

# numerical_process

lr = LabelEncoder()

cateogtical_process_1 = Pipeline(
    steps = [('lr', ce.TargetEncoder()),
             ('scaler',StandardScaler())]
    
)

cateogtical_process_2 = Pipeline(
    steps = [('lr',OneHotEncoder(sparse=False)),
             ('scaler',StandardScaler())]
    
)

X= df.iloc[:,0:-1]
y = df.iloc[:,-1]

x_train,x_test,y_train,y_test = train_test_split(X,y,test_size=0.30,random_state=42)

processsor_1 = ColumnTransformer(
    [('Categorical_encoding',cateogtical_process_1,X.select_dtypes(include="object").columns),
    ('numerical_encoding',numerical_process,X.select_dtypes(exclude="object").columns)]

)

# X.columns

from sklearn.ensemble import RandomForestClassifier
rf = RandomForestClassifier()

from sklearn.pipeline import make_pipeline
pipe_1 = make_pipeline(processsor_1,RandomForestClassifier())
pipe_2 = make_pipeline(processsor_1,DecisionTreeClassifier())
pipe_3 = make_pipeline(processsor_1,SVC(kernel='rbf',decision_function_shape='ovo'))
pipe_4 = make_pipeline(processsor_1,SVC(kernel='poly',decision_function_shape='ovo'))
pipe_5 = make_pipeline(processsor_1,KNeighborsClassifier())
pipe_6 = make_pipeline(processsor_1, GradientBoostingClassifier())

pipelines = [pipe_1, pipe_2, pipe_3, pipe_4, pipe_5, pipe_6]

for pipe in pipelines:
    pipe.fit(x_train,y_train)

models = {0: 'Random Forest Classifier', 1: 'Decision Tree Classifier', 2: 'SVC kernel: rbf', 
        3:'SVC kernel: poly', 4: 'K Neighbors Classifier', 5: 'Gradient Boosting Classifier'}

for i,model in enumerate(pipelines):
    print("{} test accuracy : {}".format(models[i],model.score(x_train,y_train)))
    print("-----------------------------------------------------------------------")

from sklearn.metrics import classification_report,confusion_matrix

for i,classifier in enumerate(pipelines):
    print(f'the classification report {models[i]} is {classification_report(y_test,classifier.predict(x_test))}')
    print("--------------------------------------------------------------------------------------------------")
    print(f'confusion matrix {models[i]} is {confusion_matrix(y_test,classifier.predict(x_test))} ')
    print("--------------------------------------------------------------------------------------------------")
    print("Al kahaf")

import streamlit as st
from pathlib import Path
# --- PATH SETTINGS ---
current_dir = Path(__file__).parent if "__file__" in locals() else Path.cwd()
css_file = current_dir / "main.css"
with open(css_file) as f:
    st.markdown("<style>{}</style>".format(f.read()), unsafe_allow_html=True)

def main():
    st.title("Music and Mental Health")
    age = st.text_input("Age", "Type Here  ")
    streaming_service = st.selectbox("Primary streaming service", ('Spotify', 'YouTube Music', 'Pandora', 'Apple Music', 'No Streaming Service', 'Others'))
    
    hours = st.number_input('Hours of Listening')
    
    working = st.selectbox('While Working', ('Yes', 'No'))
    while_working = 0
    if working == 'Yes':
        while_working = 1
        
    instrumental = st.selectbox('Do you listen to Instrumentalist?', ('Yes', 'No'))
    intrumentalist = 0
    if instrumental == 'Yes':
        intrumentalist = 1
    
    compose = st.selectbox('Do you listen to Composer?', ('Yes', 'No'))
    composer = 0
    if compose == 'Yes':
        composer = 1
    
    explorat = st.selectbox("Do you listen to exploratory music?", ('Yes', 'No'))
    exploratory = 0
    if explorat == 'Yes':
        exploratory = 1
    
    fav_genre = st.selectbox("Favourite Genre", ('Latin', 'Rock', 'Video game music', 'Jazz', 'R&B', 'K pop', 'Country', 'EDM', 'Hip hop', 'Pop', 'Rap', 'Classical', 'Metal', 'Folk', 'Lofi', 'Gospel'))

    language = st.selectbox("Do you listen Foreign Languages?", ('Yes', 'No'))
    foreign_language = 0
    if language == 'Yes':
        foreign_language = 1
    
    BPM = st.number_input('Beats per minute(BPM)')

    classical = st.selectbox("Frequency of Classical Music", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    country = st.selectbox("Frequency of Country Music", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    EDM = st.selectbox("Frequency of EDM", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    folk = st.selectbox("Frequency of Folk Music", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    gospel = st.selectbox("Frequency of Gospel", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    hiphop = st.selectbox("Frequency of Hip hop", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    jazz = st.selectbox("Frequency of Jazz", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    kpop = st.selectbox("Frequency of K pop", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    latin = st.selectbox("Frequency of Latin Music", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    lofi = st.selectbox("Frequency of Lofi", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    metal = st.selectbox("Frequency of Metal", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    pop = st.selectbox("Frequency of Pop", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    rnb = st.selectbox("Frequency of R&B", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    rap = st.selectbox("Frequency of Rap", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    rock = st.selectbox("Frequency of Rock", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))
    video_game = st.selectbox("Frequency of Video game Music", ('Rarely', 'Sometimes', 'Very frequently', 'Never'))

    anxiety = st.number_input("Anxiety level from a scale of one to ten", min_value=0, max_value=10)
    depression = st.number_input("Depression level from a scale of one to ten", min_value=0, max_value=10)
    insomnia = st.number_input("Insomnia level from a scale of one to ten", min_value=0, max_value=10)
    ocd = st.number_input("OCD level from a scale of one to ten", min_value=0, max_value=10)

    input = [age, streaming_service, hours, while_working, intrumentalist, composer, fav_genre, exploratory, foreign_language, BPM, classical, country, EDM, folk, gospel, hiphop, jazz, kpop, latin, lofi, metal, pop, rnb, rap, video_game, anxiety, depression, insomnia, ocd]
    result = ""
    if st.button("Mental Health"):
        result = pipe_4.predict(input)
    st.success("The output is {}".format(result))
    

    
    




    


if __name__ == '__main__':
    main()
